{"ast":null,"code":"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\");\nvar reducible = require(\"reducible/reducible\");\nvar isError = require(\"reducible/is-error\");\nvar end = require(\"reducible/end\");\nfunction reducer(process) {\n  /**\n  Convenience function to simplify definitions of transformation function, to\n  avoid manual definition of `reducible` results and currying transformation\n  function. It creates typical transformation function with a following\n  signature:\n       transform(source, options)\n   From a pure data `process` function that is called on each value for a\n  collection with following arguments:\n     1. `options` - Options passed to the resulting transformation function\n       most commonly that's a function like in `map(source, f)`.\n    2. `next` - Function which needs to be invoked with transformed value,\n       or simply not called to skip the value.\n    3. `value` - Last value emitted by a collection being reduced.\n    4. `result` - Accumulate value.\n   Function is supposed to return new, accumulated `result`. It may either\n  pass mapped transformed `value` and `result` to the `next` continuation\n  or skip it.\n   For example see `map` and `filter` functions.\n  **/\n  return function reducer(source, options) {\n    // When return transformation function is called with a source and\n    // `options`\n    return reducible(function reduceReducer(next, initial) {\n      // When actual result is \n      reduce(source, function reduceReducerSource(value, result) {\n        // If value is `end` of source or an error just propagate through,\n        // otherwise call `process` with all the curried `options` and `next`\n        // continuation function.\n        return value === end ? next(value, result) : isError(value) ? next(value, result) : process(options, next, value, result);\n      });\n    });\n  };\n}\nmodule.exports = reducer;","map":{"version":3,"names":["reduce","require","reducible","isError","end","reducer","process","source","options","reduceReducer","next","initial","reduceReducerSource","value","result","module","exports"],"sources":["D:/New folder (3)/websites/node_modules/reducers/reducer.js"],"sourcesContent":["\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar reducible = require(\"reducible/reducible\")\nvar isError = require(\"reducible/is-error\")\nvar end = require(\"reducible/end\")\n\n\nfunction reducer(process) {\n  /**\n  Convenience function to simplify definitions of transformation function, to\n  avoid manual definition of `reducible` results and currying transformation\n  function. It creates typical transformation function with a following\n  signature:\n\n      transform(source, options)\n\n  From a pure data `process` function that is called on each value for a\n  collection with following arguments:\n\n    1. `options` - Options passed to the resulting transformation function\n       most commonly that's a function like in `map(source, f)`.\n    2. `next` - Function which needs to be invoked with transformed value,\n       or simply not called to skip the value.\n    3. `value` - Last value emitted by a collection being reduced.\n    4. `result` - Accumulate value.\n\n  Function is supposed to return new, accumulated `result`. It may either\n  pass mapped transformed `value` and `result` to the `next` continuation\n  or skip it.\n\n  For example see `map` and `filter` functions.\n  **/\n  return function reducer(source, options) {\n    // When return transformation function is called with a source and\n    // `options`\n    return reducible(function reduceReducer(next, initial) {\n      // When actual result is \n      reduce(source, function reduceReducerSource(value, result) {\n        // If value is `end` of source or an error just propagate through,\n        // otherwise call `process` with all the curried `options` and `next`\n        // continuation function.\n        return value === end ? next(value, result) :\n               isError(value) ? next(value, result) :\n               process(options, next, value, result)\n      })\n    })\n  }\n}\n\nmodule.exports = reducer\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AACxC,IAAIC,SAAS,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AAC9C,IAAIE,OAAO,GAAGF,OAAO,CAAC,oBAAoB,CAAC;AAC3C,IAAIG,GAAG,GAAGH,OAAO,CAAC,eAAe,CAAC;AAGlC,SAASI,OAAOA,CAACC,OAAO,EAAE;EACxB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAME,OAAO,SAASD,OAAOA,CAACE,MAAM,EAAEC,OAAO,EAAE;IACvC;IACA;IACA,OAAON,SAAS,CAAC,SAASO,aAAaA,CAACC,IAAI,EAAEC,OAAO,EAAE;MACrD;MACAX,MAAM,CAACO,MAAM,EAAE,SAASK,mBAAmBA,CAACC,KAAK,EAAEC,MAAM,EAAE;QACzD;QACA;QACA;QACA,OAAOD,KAAK,KAAKT,GAAG,GAAGM,IAAI,CAACG,KAAK,EAAEC,MAAM,CAAC,GACnCX,OAAO,CAACU,KAAK,CAAC,GAAGH,IAAI,CAACG,KAAK,EAAEC,MAAM,CAAC,GACpCR,OAAO,CAACE,OAAO,EAAEE,IAAI,EAAEG,KAAK,EAAEC,MAAM,CAAC;MAC9C,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC;AACH;AAEAC,MAAM,CAACC,OAAO,GAAGX,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}