{"ast":null,"code":"\"use strict\";\n\nvar reduce = require(\"./reduce\");\nvar end = require(\"./end\");\nvar isError = require(\"./is-error\");\nvar isReduced = require(\"./is-reduced\");\nvar reduced = require(\"./reduced\");\nfunction Reducible(reduce) {\n  /**\n  Reducible is a type of the data-structure that represents something\n  that can be reduced. Most of the time it's used to represent transformation\n  over other reducible by capturing it in a lexical scope.\n   Reducible has an attribute `reduce` pointing to a function that does\n  reduction.\n  **/\n\n  // JS engines optimize access to properties that are set in the constructor's\n  // so we set it here.\n  this.reduce = reduce;\n}\n\n// Implementation of `accumulate` for reducible, which just delegates to it's\n// `reduce` attribute.\nreduce.define(Reducible, function reduceReducible(reducible, next, initial) {\n  var result;\n  // State is intentionally accumulated in the outer variable, that way no\n  // matter if consumer is broken and passes in wrong accumulated state back\n  // this reducible will still accumulate result as intended.\n  var state = initial;\n  try {\n    reducible.reduce(function forward(value) {\n      try {\n        // If reduction has already being completed return is set to\n        // an accumulated state boxed via `reduced`. It's set to state\n        // that is return to signal input that reduction is complete.\n        if (result) state = result;\n        // if dispatched `value` is is special `end` of input one or an error\n        // just forward to reducer and store last state boxed as `reduced` into\n        // state. Later it will be assigned to result and returned to input\n        // to indicate end of reduction.\n        else if (value === end || isError(value)) {\n          next(value, state);\n          state = reduced(state);\n        }\n        // if non of above just accumulate new state by passing value and\n        // previously accumulate state to reducer.\n        else state = next(value, state);\n\n        // If state is boxed with `reduced` then accumulation is complete.\n        // Indicated explicitly by a reducer or by end / error of the input.\n        // Either way store it to the result in case broken input attempts to\n        // call forward again.\n        if (isReduced(state)) result = state;\n\n        // return accumulated state back either way.\n        return state;\n      }\n      // If error is thrown then forward it to the reducer such that consumer\n      // can apply recovery logic. Also store current `state` boxed with\n      // `reduced` to signal input that reduction is complete.\n      catch (error) {\n        next(error, state);\n        result = reduced(state);\n        return result;\n      }\n    });\n  }\n  // It could be that attempt to reduce underlaying reducible throws, if that\n  // is the case still forward an `error` to a reducer and store reduced state\n  // into result, in case process of reduction started before exception and\n  // forward will still be called. Return result either way to signal\n  // completion.\n  catch (error) {\n    next(error, state);\n    result = reduced(state);\n    return result;\n  }\n});\nfunction reducible(reduce) {\n  return new Reducible(reduce);\n}\nreducible.type = Reducible;\nmodule.exports = reducible;","map":{"version":3,"names":["reduce","require","end","isError","isReduced","reduced","Reducible","define","reduceReducible","reducible","next","initial","result","state","forward","value","error","type","module","exports"],"sources":["D:/New folder (3)/websites/node_modules/reducible/reducible.js"],"sourcesContent":["\"use strict\";\n\nvar reduce = require(\"./reduce\")\nvar end = require(\"./end\")\nvar isError = require(\"./is-error\")\nvar isReduced = require(\"./is-reduced\")\nvar reduced = require(\"./reduced\")\n\nfunction Reducible(reduce) {\n  /**\n  Reducible is a type of the data-structure that represents something\n  that can be reduced. Most of the time it's used to represent transformation\n  over other reducible by capturing it in a lexical scope.\n\n  Reducible has an attribute `reduce` pointing to a function that does\n  reduction.\n  **/\n\n  // JS engines optimize access to properties that are set in the constructor's\n  // so we set it here.\n  this.reduce = reduce\n}\n\n// Implementation of `accumulate` for reducible, which just delegates to it's\n// `reduce` attribute.\nreduce.define(Reducible, function reduceReducible(reducible, next, initial) {\n  var result\n  // State is intentionally accumulated in the outer variable, that way no\n  // matter if consumer is broken and passes in wrong accumulated state back\n  // this reducible will still accumulate result as intended.\n  var state = initial\n  try {\n    reducible.reduce(function forward(value) {\n      try {\n        // If reduction has already being completed return is set to\n        // an accumulated state boxed via `reduced`. It's set to state\n        // that is return to signal input that reduction is complete.\n        if (result) state = result\n        // if dispatched `value` is is special `end` of input one or an error\n        // just forward to reducer and store last state boxed as `reduced` into\n        // state. Later it will be assigned to result and returned to input\n        // to indicate end of reduction.\n        else if (value === end || isError(value)) {\n          next(value, state)\n          state = reduced(state)\n        }\n        // if non of above just accumulate new state by passing value and\n        // previously accumulate state to reducer.\n        else state = next(value, state)\n\n        // If state is boxed with `reduced` then accumulation is complete.\n        // Indicated explicitly by a reducer or by end / error of the input.\n        // Either way store it to the result in case broken input attempts to\n        // call forward again.\n        if (isReduced(state)) result = state\n\n        // return accumulated state back either way.\n        return state\n      }\n      // If error is thrown then forward it to the reducer such that consumer\n      // can apply recovery logic. Also store current `state` boxed with\n      // `reduced` to signal input that reduction is complete.\n      catch (error) {\n        next(error, state)\n        result = reduced(state)\n        return result\n      }\n    })\n  }\n  // It could be that attempt to reduce underlaying reducible throws, if that\n  // is the case still forward an `error` to a reducer and store reduced state\n  // into result, in case process of reduction started before exception and\n  // forward will still be called. Return result either way to signal\n  // completion.\n  catch(error) {\n    next(error, state)\n    result = reduced(state)\n    return result\n  }\n})\n\nfunction reducible(reduce) {\n  return new Reducible(reduce)\n}\nreducible.type = Reducible\n\nmodule.exports = reducible\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,UAAU,CAAC;AAChC,IAAIC,GAAG,GAAGD,OAAO,CAAC,OAAO,CAAC;AAC1B,IAAIE,OAAO,GAAGF,OAAO,CAAC,YAAY,CAAC;AACnC,IAAIG,SAAS,GAAGH,OAAO,CAAC,cAAc,CAAC;AACvC,IAAII,OAAO,GAAGJ,OAAO,CAAC,WAAW,CAAC;AAElC,SAASK,SAASA,CAACN,MAAM,EAAE;EACzB;AACF;AACA;AACA;AACA;AACA;AACA;;EAGE;EACA;EACA,IAAI,CAACA,MAAM,GAAGA,MAAM;AACtB;;AAEA;AACA;AACAA,MAAM,CAACO,MAAM,CAACD,SAAS,EAAE,SAASE,eAAeA,CAACC,SAAS,EAAEC,IAAI,EAAEC,OAAO,EAAE;EAC1E,IAAIC,MAAM;EACV;EACA;EACA;EACA,IAAIC,KAAK,GAAGF,OAAO;EACnB,IAAI;IACFF,SAAS,CAACT,MAAM,CAAC,SAASc,OAAOA,CAACC,KAAK,EAAE;MACvC,IAAI;QACF;QACA;QACA;QACA,IAAIH,MAAM,EAAEC,KAAK,GAAGD,MAAM;QAC1B;QACA;QACA;QACA;QAAA,KACK,IAAIG,KAAK,KAAKb,GAAG,IAAIC,OAAO,CAACY,KAAK,CAAC,EAAE;UACxCL,IAAI,CAACK,KAAK,EAAEF,KAAK,CAAC;UAClBA,KAAK,GAAGR,OAAO,CAACQ,KAAK,CAAC;QACxB;QACA;QACA;QAAA,KACKA,KAAK,GAAGH,IAAI,CAACK,KAAK,EAAEF,KAAK,CAAC;;QAE/B;QACA;QACA;QACA;QACA,IAAIT,SAAS,CAACS,KAAK,CAAC,EAAED,MAAM,GAAGC,KAAK;;QAEpC;QACA,OAAOA,KAAK;MACd;MACA;MACA;MACA;MACA,OAAOG,KAAK,EAAE;QACZN,IAAI,CAACM,KAAK,EAAEH,KAAK,CAAC;QAClBD,MAAM,GAAGP,OAAO,CAACQ,KAAK,CAAC;QACvB,OAAOD,MAAM;MACf;IACF,CAAC,CAAC;EACJ;EACA;EACA;EACA;EACA;EACA;EACA,OAAMI,KAAK,EAAE;IACXN,IAAI,CAACM,KAAK,EAAEH,KAAK,CAAC;IAClBD,MAAM,GAAGP,OAAO,CAACQ,KAAK,CAAC;IACvB,OAAOD,MAAM;EACf;AACF,CAAC,CAAC;AAEF,SAASH,SAASA,CAACT,MAAM,EAAE;EACzB,OAAO,IAAIM,SAAS,CAACN,MAAM,CAAC;AAC9B;AACAS,SAAS,CAACQ,IAAI,GAAGX,SAAS;AAE1BY,MAAM,CAACC,OAAO,GAAGV,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}