{"ast":null,"code":"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\");\nvar reduced = require(\"reducible/reduced\");\nvar isReduced = require(\"reducible/is-reduced\");\nvar end = require(\"reducible/end\");\nvar input = \"input@\" + module.id;\nvar consumers = \"consumers@\" + module.id;\nvar isArray = Array.isArray;\nfunction Hub(source) {\n  this[input] = source;\n  this[consumers] = [];\n}\nreduce.define(Hub, function reduceHub(hub, next, initial) {\n  // Enqueue new consumer into consumers array so that new\n  // values will be delegated to it.\n  hub[consumers].push({\n    next: next,\n    state: initial\n  });\n  // If source is not in the process of consumption than\n  // start it up.\n  if (!isOpen(hub)) open(hub);\n});\nfunction drain(consumers) {\n  while (consumers.length) {\n    var count = consumers.length;\n    var index = 0;\n    while (index < count) {\n      var consumer = consumers[index];\n      consumer.next(end, consumer.state);\n      index = index + 1;\n    }\n    consumers.splice(0, count);\n  }\n}\nfunction dispatch(consumers, value) {\n  var count = consumers.length;\n  var index = 0;\n  while (index < count) {\n    var consumer = consumers[index];\n    var state = consumer.next(value, consumer.state);\n    // If consumer has finished accumulation remove it from the consumers\n    // list. And dispatch end of stream on it (maybe that should not be\n    // necessary).\n    if (isReduced(state)) {\n      consumers.splice(index, 1);\n      consumer.next(end, state.value);\n      // If consumer is removed than we decrease count as consumers array\n      // will contain less elements (unless of course more elements were\n      // added but we would like to ignore those).\n      count = count - 1;\n    } else {\n      consumer.state = state;\n      index = index + 1;\n    }\n  }\n}\nfunction open(hub) {\n  var source = hub[input];\n  var reducers = hub[consumers];\n  hub[input] = null; // mark hub as open\n  reduce(source, function distribute(value) {\n    // If it's end of the source we close all the reducers including\n    // ones that subscribe as side effect.\n    if (value === end) drain(reducers);\n    // otherwise we dispatch value to all the registered reducers.\n    else dispatch(reducers, value);\n\n    // reducers will be empty if either source is drained or if all the\n    // reducers finished reductions. Either way we reset input back to\n    // source and return `reduced` marker to stop the reduction of\n    // source.\n    if (reducers.length === 0) {\n      hub[input] = source;\n      return reduced();\n    }\n  });\n}\nfunction isOpen(hub) {\n  return hub[input] === null;\n}\nfunction hub(source) {\n  /**\n  Take a reducible `source`, such as a `signal` and return a reducible that can\n  be consumed by many reducers.\n  **/\n  if (source === null) return null;\n  if (source === void 0) return null;\n  return new Hub(source);\n}\nhub.isOpen = isOpen;\nhub.type = Hub;\nmodule.exports = hub;","map":{"version":3,"names":["reduce","require","reduced","isReduced","end","input","module","id","consumers","isArray","Array","Hub","source","define","reduceHub","hub","next","initial","push","state","isOpen","open","drain","length","count","index","consumer","splice","dispatch","value","reducers","distribute","type","exports"],"sources":["D:/New folder (3)/websites/node_modules/reducers/hub.js"],"sourcesContent":["\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar reduced = require(\"reducible/reduced\")\nvar isReduced = require(\"reducible/is-reduced\")\nvar end = require(\"reducible/end\")\n\nvar input = \"input@\" + module.id\nvar consumers = \"consumers@\" + module.id\n\n\nvar isArray = Array.isArray\n\nfunction Hub(source) {\n  this[input] = source\n  this[consumers] = []\n}\n\nreduce.define(Hub, function reduceHub(hub, next, initial) {\n  // Enqueue new consumer into consumers array so that new\n  // values will be delegated to it.\n  hub[consumers].push({ next: next, state: initial })\n  // If source is not in the process of consumption than\n  // start it up.\n  if (!isOpen(hub)) open(hub)\n})\n\nfunction drain(consumers) {\n  while (consumers.length) {\n    var count = consumers.length\n    var index = 0\n    while (index < count) {\n      var consumer = consumers[index]\n      consumer.next(end, consumer.state)\n      index = index + 1\n    }\n    consumers.splice(0, count)\n  }\n}\n\nfunction dispatch(consumers, value) {\n  var count = consumers.length\n  var index = 0\n  while (index < count) {\n    var consumer = consumers[index]\n    var state = consumer.next(value, consumer.state)\n    // If consumer has finished accumulation remove it from the consumers\n    // list. And dispatch end of stream on it (maybe that should not be\n    // necessary).\n    if (isReduced(state)) {\n      consumers.splice(index, 1)\n      consumer.next(end, state.value)\n      // If consumer is removed than we decrease count as consumers array\n      // will contain less elements (unless of course more elements were\n      // added but we would like to ignore those).\n      count = count - 1\n    } else {\n      consumer.state = state\n      index = index + 1\n    }\n  }\n}\n\nfunction open(hub) {\n  var source = hub[input]\n  var reducers = hub[consumers]\n  hub[input] = null         // mark hub as open\n  reduce(source, function distribute(value) {\n    // If it's end of the source we close all the reducers including\n    // ones that subscribe as side effect.\n    if (value === end) drain(reducers)\n    // otherwise we dispatch value to all the registered reducers.\n    else dispatch(reducers, value)\n\n    // reducers will be empty if either source is drained or if all the\n    // reducers finished reductions. Either way we reset input back to\n    // source and return `reduced` marker to stop the reduction of\n    // source.\n    if (reducers.length === 0) {\n      hub[input] = source\n      return reduced()\n    }\n  })\n}\n\nfunction isOpen(hub) {\n  return hub[input] === null\n}\n\nfunction hub(source) {\n  /**\n  Take a reducible `source`, such as a `signal` and return a reducible that can\n  be consumed by many reducers.\n  **/\n  if (source === null) return null\n  if (source === void(0)) return null\n  return new Hub(source)\n}\nhub.isOpen = isOpen\nhub.type = Hub\n\nmodule.exports = hub\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}