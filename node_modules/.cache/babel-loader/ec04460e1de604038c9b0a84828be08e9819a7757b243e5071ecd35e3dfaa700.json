{"ast":null,"code":"\"use strict\";\n\nvar method = require(\"method\");\nvar isReduced = require(\"./is-reduced\");\nvar isError = require(\"./is-error\");\nvar end = require(\"./end\");\nvar reduce = method(\"reduce@reducible\");\n\n// Implementation of `reduce` for the empty collections, that immediately\n// signals reducer that it's ended.\nreduce.empty = function reduceEmpty(empty, next, initial) {\n  next(end, initial);\n};\n\n// Implementation of `reduce` for the singular values which are treated\n// as collections with a single element. Yields a value and signals the end.\nreduce.singular = function reduceSingular(value, next, initial) {\n  next(end, next(value, initial));\n};\n\n// Implementation of `reduce` for the array (and alike) values, such that it\n// will call accumulator function `next` each time with next item and\n// accumulated state until it's exhausted or `next` returns marked value\n// indicating that it's reduced. Either way signals `end` to an accumulator.\nreduce.indexed = function reduceIndexed(indexed, next, initial) {\n  var state = initial;\n  var index = 0;\n  var count = indexed.length;\n  while (index < count) {\n    var value = indexed[index];\n    state = next(value, state);\n    index = index + 1;\n    if (value === end) return end;\n    if (isError(value)) return state;\n    if (isReduced(state)) return state.value;\n  }\n  next(end, state);\n};\n\n// Both `undefined` and `null` implement accumulate for empty sequences.\nreduce.define(void 0, reduce.empty);\nreduce.define(null, reduce.empty);\n\n// Array and arguments implement accumulate for indexed sequences.\nreduce.define(Array, reduce.indexed);\nfunction Arguments() {\n  return arguments;\n}\nArguments.prototype = Arguments();\nreduce.define(Arguments, reduce.indexed);\n\n// All other built-in data types are treated as single value collections\n// by default. Of course individual types may choose to override that.\nreduce.define(reduce.singular);\n\n// Errors just yield that error.\nreduce.define(Error, function (error, next) {\n  next(error);\n});\nmodule.exports = reduce;","map":{"version":3,"names":["method","require","isReduced","isError","end","reduce","empty","reduceEmpty","next","initial","singular","reduceSingular","value","indexed","reduceIndexed","state","index","count","length","define","Array","Arguments","arguments","prototype","Error","error","module","exports"],"sources":["D:/New folder (3)/websites/node_modules/reducible/reduce.js"],"sourcesContent":["\"use strict\";\n\nvar method = require(\"method\")\n\nvar isReduced = require(\"./is-reduced\")\nvar isError = require(\"./is-error\")\nvar end = require(\"./end\")\n\nvar reduce = method(\"reduce@reducible\")\n\n// Implementation of `reduce` for the empty collections, that immediately\n// signals reducer that it's ended.\nreduce.empty = function reduceEmpty(empty, next, initial) {\n  next(end, initial)\n}\n\n// Implementation of `reduce` for the singular values which are treated\n// as collections with a single element. Yields a value and signals the end.\nreduce.singular = function reduceSingular(value, next, initial) {\n  next(end, next(value, initial))\n}\n\n// Implementation of `reduce` for the array (and alike) values, such that it\n// will call accumulator function `next` each time with next item and\n// accumulated state until it's exhausted or `next` returns marked value\n// indicating that it's reduced. Either way signals `end` to an accumulator.\nreduce.indexed = function reduceIndexed(indexed, next, initial) {\n  var state = initial\n  var index = 0\n  var count = indexed.length\n  while (index < count) {\n    var value = indexed[index]\n    state = next(value, state)\n    index = index + 1\n    if (value === end) return end\n    if (isError(value)) return state\n    if (isReduced(state)) return state.value\n  }\n  next(end, state)\n}\n\n// Both `undefined` and `null` implement accumulate for empty sequences.\nreduce.define(void(0), reduce.empty)\nreduce.define(null, reduce.empty)\n\n// Array and arguments implement accumulate for indexed sequences.\nreduce.define(Array, reduce.indexed)\n\nfunction Arguments() { return arguments }\nArguments.prototype = Arguments()\nreduce.define(Arguments, reduce.indexed)\n\n// All other built-in data types are treated as single value collections\n// by default. Of course individual types may choose to override that.\nreduce.define(reduce.singular)\n\n// Errors just yield that error.\nreduce.define(Error, function(error, next) { next(error) })\nmodule.exports = reduce\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAE9B,IAAIC,SAAS,GAAGD,OAAO,CAAC,cAAc,CAAC;AACvC,IAAIE,OAAO,GAAGF,OAAO,CAAC,YAAY,CAAC;AACnC,IAAIG,GAAG,GAAGH,OAAO,CAAC,OAAO,CAAC;AAE1B,IAAII,MAAM,GAAGL,MAAM,CAAC,kBAAkB,CAAC;;AAEvC;AACA;AACAK,MAAM,CAACC,KAAK,GAAG,SAASC,WAAWA,CAACD,KAAK,EAAEE,IAAI,EAAEC,OAAO,EAAE;EACxDD,IAAI,CAACJ,GAAG,EAAEK,OAAO,CAAC;AACpB,CAAC;;AAED;AACA;AACAJ,MAAM,CAACK,QAAQ,GAAG,SAASC,cAAcA,CAACC,KAAK,EAAEJ,IAAI,EAAEC,OAAO,EAAE;EAC9DD,IAAI,CAACJ,GAAG,EAAEI,IAAI,CAACI,KAAK,EAAEH,OAAO,CAAC,CAAC;AACjC,CAAC;;AAED;AACA;AACA;AACA;AACAJ,MAAM,CAACQ,OAAO,GAAG,SAASC,aAAaA,CAACD,OAAO,EAAEL,IAAI,EAAEC,OAAO,EAAE;EAC9D,IAAIM,KAAK,GAAGN,OAAO;EACnB,IAAIO,KAAK,GAAG,CAAC;EACb,IAAIC,KAAK,GAAGJ,OAAO,CAACK,MAAM;EAC1B,OAAOF,KAAK,GAAGC,KAAK,EAAE;IACpB,IAAIL,KAAK,GAAGC,OAAO,CAACG,KAAK,CAAC;IAC1BD,KAAK,GAAGP,IAAI,CAACI,KAAK,EAAEG,KAAK,CAAC;IAC1BC,KAAK,GAAGA,KAAK,GAAG,CAAC;IACjB,IAAIJ,KAAK,KAAKR,GAAG,EAAE,OAAOA,GAAG;IAC7B,IAAID,OAAO,CAACS,KAAK,CAAC,EAAE,OAAOG,KAAK;IAChC,IAAIb,SAAS,CAACa,KAAK,CAAC,EAAE,OAAOA,KAAK,CAACH,KAAK;EAC1C;EACAJ,IAAI,CAACJ,GAAG,EAAEW,KAAK,CAAC;AAClB,CAAC;;AAED;AACAV,MAAM,CAACc,MAAM,CAAC,KAAK,CAAE,EAAEd,MAAM,CAACC,KAAK,CAAC;AACpCD,MAAM,CAACc,MAAM,CAAC,IAAI,EAAEd,MAAM,CAACC,KAAK,CAAC;;AAEjC;AACAD,MAAM,CAACc,MAAM,CAACC,KAAK,EAAEf,MAAM,CAACQ,OAAO,CAAC;AAEpC,SAASQ,SAASA,CAAA,EAAG;EAAE,OAAOC,SAAS;AAAC;AACxCD,SAAS,CAACE,SAAS,GAAGF,SAAS,CAAC,CAAC;AACjChB,MAAM,CAACc,MAAM,CAACE,SAAS,EAAEhB,MAAM,CAACQ,OAAO,CAAC;;AAExC;AACA;AACAR,MAAM,CAACc,MAAM,CAACd,MAAM,CAACK,QAAQ,CAAC;;AAE9B;AACAL,MAAM,CAACc,MAAM,CAACK,KAAK,EAAE,UAASC,KAAK,EAAEjB,IAAI,EAAE;EAAEA,IAAI,CAACiB,KAAK,CAAC;AAAC,CAAC,CAAC;AAC3DC,MAAM,CAACC,OAAO,GAAGtB,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}